<!doctype html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>For My Lil` Boy</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    html,body{height:100%; background:#000; overflow:hidden; font-family:system-ui,Segoe UI,Arial;}
    canvas{position:fixed; inset:0; width:100%; height:100%; display:block;}

    #startBtn{
      position:fixed; left:50%; top:50%;
      transform:translate(-50%,-50%);
      padding:18px 64px;
      font-size:26px;
      border:none; border-radius:999px;
      color:#fff; cursor:pointer;
      background:linear-gradient(45deg,#ff2d8a,#7a3cff,#00d7ff);
      box-shadow:0 0 30px rgba(255,45,138,.65);
      transition:.25s; z-index:5;
    }
    #startBtn:hover{transform:translate(-50%,-50%) scale(1.06);}

    .caption{
      position:fixed;
      left:50%; bottom:8.2vh;
      transform:translateX(-50%);
      color:rgba(255,255,255,.96);
      font-size:30px;
      letter-spacing:.4px;
      text-shadow:0 0 22px rgba(255,255,255,.25);
      opacity:0;
      filter:blur(12px);
      transition:opacity .8s ease, filter .8s ease, transform .8s ease;
      z-index:4;
      pointer-events:none;
      white-space:nowrap;
    }
    .caption.show{
      opacity:1;
      filter:blur(0px);
      transform:translateX(-50%) translateY(-8px);
    }
    .subtitle{
      position:fixed;
      left:50%; bottom:4.2vh;
      transform:translateX(-50%);
      color:rgba(255,255,255,.72);
      font-size:17px;
      opacity:0;
      transition:opacity 1s ease;
      z-index:4;
      pointer-events:none;
      white-space:nowrap;
    }
    .subtitle.show{opacity:1;}
  </style>
</head>
<body>
  <button id="startBtn">START</button>

  <!-- هنكتب النص ديناميك (typewriter) -->
  <div class="caption" id="caption"></div>
  <div class="subtitle" id="subtitle"></div>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: true });
    const btn = document.getElementById("startBtn");
    const caption = document.getElementById("caption");
    const subtitle = document.getElementById("subtitle");

    // ==========================
    // ✅ مكان الخلفية (إنت هتحط الصورة جنب ملف الـ HTML)
    // غيّر الاسم براحتك
    // ==========================
    const BG_SRC = "pic.jpg";
    const bgImg = new Image();
    bgImg.src = BG_SRC;

    // ==========================
    // ✅ مكان الصوت (إنت هتحط الأغنية جنب ملف الـ HTML)
    // غيّر الاسم براحتك
    // ==========================
    const AUDIO_SRC = "song.m4a";
    const bgAudio = new Audio(AUDIO_SRC);
    bgAudio.loop = true;
    bgAudio.preload = "auto";
    bgAudio.volume = 0.85;

    let W=0,H=0,DPR=1;
    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W+"px";
      canvas.style.height = H+"px";
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------- helpers ----------
    const TAU = Math.PI * 2;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const rand = (a,b)=>a+Math.random()*(b-a);
    const pick = arr => arr[(Math.random()*arr.length)|0];

    // ===== Background: image cover + cinematic overlays =====
    function drawCoverImage(img){
      if(!img.complete || !img.naturalWidth){
        const g = ctx.createLinearGradient(0,0,W,H);
        g.addColorStop(0, "#05040a");
        g.addColorStop(0.5, "#040010");
        g.addColorStop(1, "#00060a");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);
        return;
      }

      const iw = img.naturalWidth, ih = img.naturalHeight;
      const scale = Math.max(W/iw, H/ih);
      const dw = iw * scale, dh = ih * scale;
      const dx = (W - dw) / 2;
      const dy = (H - dh) / 2;

      ctx.save();
      ctx.filter = "blur(1.8px) saturate(1.08) contrast(1.08) brightness(0.95)";
      ctx.drawImage(img, dx, dy, dw, dh);
      ctx.filter = "none";

      ctx.fillStyle = "rgba(0,0,0,0.58)";
      ctx.fillRect(0,0,W,H);

      const v = ctx.createRadialGradient(W/2, H/2, 20, W/2, H/2, Math.min(W,H)*0.78);
      v.addColorStop(0, "rgba(0,0,0,0)");
      v.addColorStop(1, "rgba(0,0,0,0.62)");
      ctx.fillStyle = v;
      ctx.fillRect(0,0,W,H);

      const wash = ctx.createLinearGradient(0,0,W,H);
      wash.addColorStop(0, "rgba(255,70,160,0.10)");
      wash.addColorStop(0.55, "rgba(120,70,255,0.08)");
      wash.addColorStop(1, "rgba(0,220,255,0.06)");
      ctx.fillStyle = wash;
      ctx.fillRect(0,0,W,H);

      ctx.restore();
    }

    // ---------- background particles ----------
    class Bokeh {
      constructor(){ this.reset(true); }
      reset(first=false){
        this.x = rand(0, W);
        this.y = rand(0, H);
        this.r = rand(22, 140);
        this.vx = rand(-0.10, 0.10);
        this.vy = rand(-0.12, 0.08);
        this.a = rand(0.025, 0.08) * (first?0.7:1);
        this.h = rand(285, 360);
      }
      update(){
        this.x += this.vx;
        this.y += this.vy;
        if(this.x < -240 || this.x > W+240 || this.y < -240 || this.y > H+240) this.reset();
      }
      draw(){
        ctx.save();
        ctx.globalCompositeOperation = "screen";
        ctx.globalAlpha = this.a;
        ctx.shadowBlur = this.r * 0.30;
        ctx.shadowColor = `hsla(${this.h}, 90%, 65%, 0.7)`;
        ctx.fillStyle = `hsla(${this.h}, 90%, 55%, 0.10)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();
        ctx.restore();
      }
    }

    class FloatHeart {
      constructor(){ this.reset(true); }
      reset(first=false){
        this.x = rand(0, W);
        this.y = first ? rand(0, H) : H + rand(30, 260);
        this.s = rand(6, 16);
        this.vy = rand(0.14, 0.38);
        this.vx = rand(-0.06, 0.06);
        this.rot = rand(0, TAU);
        this.rspd = rand(-0.012, 0.012);
        this.a = rand(0.03, 0.10);
        this.h = rand(320, 360);
      }
      update(){
        this.x += this.vx;
        this.y -= this.vy;
        this.rot += this.rspd;
        if(this.y < -220) this.reset();
      }
      draw(){
        ctx.save();
        ctx.translate(this.x,this.y);
        ctx.rotate(this.rot);
        ctx.globalAlpha = this.a;
        ctx.globalCompositeOperation = "lighter";
        ctx.shadowBlur = 16;
        ctx.shadowColor = `hsla(${this.h}, 95%, 70%, .65)`;
        ctx.fillStyle = `hsla(${this.h}, 95%, 65%, .20)`;
        drawMiniHeart(0,0,this.s);
        ctx.restore();
      }
    }

    function drawMiniHeart(x,y,sz){
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - sz, y - sz, x - 2*sz, y + sz*0.6, x, y + 2*sz);
      ctx.bezierCurveTo(x + 2*sz, y + sz*0.6, x + sz, y - sz, x, y);
      ctx.closePath();
      ctx.fill();
    }

    // ---------- heart geometry ----------
    function heartPoint(t){
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
      return {x, y};
    }
    function buildHeartTargets(count){
      const targets = [];
      for(let i=0;i<count;i++){
        const t = (i / count) * TAU;
        targets.push(heartPoint(t));
      }
      return targets;
    }
    const HEART_POINTS = buildHeartTargets(980);

    function mapToScreen(p, cx, cy, size){
      return {
        x: cx + (p.x / 16) * size,
        y: cy - (p.y / 17) * size
      };
    }

    function edgeSpawn(){
      const side = (Math.random()*4)|0;
      const pad = 50;
      let x,y;
      if(side===0){ x=rand(-pad,W+pad); y=-pad; }
      if(side===1){ x=W+pad; y=rand(-pad,H+pad); }
      if(side===2){ x=rand(-pad,W+pad); y=H+pad; }
      if(side===3){ x=-pad; y=rand(-pad,H+pad); }
      return {x,y};
    }

    function rayColor(tBias=0){
      const anchors = [330, 300, 260, 210];
      const h = (pick(anchors) + rand(-14,14) + tBias) % 360;
      return `hsla(${h}, 98%, 64%, 0.96)`;
    }

    // ---------- Rays ----------
    class Ray {
      constructor(target, swirlSign){
        const s = edgeSpawn();
        this.x = s.x; this.y = s.y;
        this.px = this.x; this.py = this.y;

        this.tx = target.x;
        this.ty = target.y;

        this.width = rand(1.0, 2.6);

        // ===== تعديل: سرعة أعلى شوية + سلاسة بالـ dt =====
        this.speed = rand(0.24, 0.40);

        this.life = 1.0;
        // تموت أبطأ شوية عشان الترِيل يبقى ناعم
        this.fade = rand(0.008, 0.014);

        this.col = rayColor();
        this.glow = rand(16, 34);

        this.swirl = swirlSign * rand(0.7, 1.9);
        this.phase = rand(0, TAU);

        this.arrived = false;
        this.arrivalRadius = rand(7, 12);
      }

      // dt بالثواني
      update(now, dt, cx, cy){
        this.px = this.x; this.py = this.y;

        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const dist = Math.hypot(dx,dy) || 1;

        const ux = dx / dist;
        const uy = dy / dist;

        const cdx = cx - this.x;
        const cdy = cy - this.y;
        const cdist = Math.hypot(cdx,cdy) || 1;
        const cxu = cdx / cdist;
        const cyu = cdy / cdist;

        const px = -cyu;
        const py =  cxu;

        const swirlK = this.swirl * Math.min(1, dist / (Math.min(W,H)*0.42));
        const wobble = Math.sin(now*0.0032 + this.phase) * 0.30;

        const vx = (ux + px*swirlK*0.085 + (-uy)*wobble*0.06);
        const vy = (uy + py*swirlK*0.085 + ( ux)*wobble*0.06);

        const accel = 0.95 + (1 - clamp(dist/(Math.min(W,H)*0.85), 0, 1)) * 1.15;

        // ===== تعديل: time-based step (سلاسة ثابتة على أي FPS) =====
        const step = (18 * this.speed) * accel * (dt * 60);
        this.x += vx * step;
        this.y += vy * step;

        if(dist < this.arrivalRadius){
          this.arrived = true;
          this.life -= this.fade * 2.6 * (dt * 60);
        } else {
          this.life -= this.fade * 0.55 * (dt * 60);
        }

        return this.life > 0;
      }

      draw(){
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.globalAlpha = clamp(this.life, 0, 1);

        ctx.shadowBlur = this.glow;
        ctx.shadowColor = this.col;

        const grad = ctx.createLinearGradient(this.px,this.py,this.x,this.y);
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(0.22, this.col);
        grad.addColorStop(1, "rgba(255,255,255,0.10)");

        ctx.strokeStyle = grad;
        ctx.lineWidth = this.width;

        ctx.beginPath();
        ctx.moveTo(this.px, this.py);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();

        ctx.globalAlpha *= 0.65;
        ctx.fillStyle = this.col;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.width*1.25, 0, TAU);
        ctx.fill();

        ctx.restore();
      }
    }

    // ---------- Heart glow map ----------
    let heartGlow = [];
    function resetHeartGlow(n){
      heartGlow = new Array(n).fill(0);
    }

    // ===== تعديل: decay أبطأ شوية عشان يتجمع خلال 5 ثواني بدل ما يختفي =====
    function updateHeartGlow(dt){
      const decay = Math.pow(0.992, dt*60); // ثابت مع fps
      for(let i=0;i<heartGlow.length;i++){
        heartGlow[i] *= decay;
        if(heartGlow[i] < 0.001) heartGlow[i] = 0;
      }
    }

    function getFormedRatio(){
      let c=0;
      for(const v of heartGlow) if(v > 0.20) c++;
      return c / heartGlow.length;
    }

    function drawDottedHeart(cx, cy, size, baseAlpha){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      for(let i=0;i<HEART_POINTS.length;i++){
        const g = heartGlow[i];
        if(g <= 0.001) continue;

        const p = mapToScreen(HEART_POINTS[i], cx, cy, size);
        const a = clamp(baseAlpha * (0.22 + g*0.95), 0, 1);
        ctx.globalAlpha = a;

        const hue = (325 + (i/HEART_POINTS.length)*85) % 360;
        ctx.shadowBlur = 28 + g*46;
        ctx.shadowColor = `hsla(${hue}, 98%, 70%, 0.92)`;
        ctx.fillStyle = `hsla(${hue}, 98%, 66%, ${0.20 + g*0.40})`;

        const r = 1.25 + g*2.9;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, TAU);
        ctx.fill();
      }

      const formed = getFormedRatio();
      if(formed > 0.30){
        ctx.globalAlpha = (formed-0.30) * 0.45;
        ctx.shadowBlur = 110;
        ctx.shadowColor = "rgba(255,90,200,0.65)";
        const aura = ctx.createRadialGradient(cx,cy,10, cx,cy, size*1.55);
        aura.addColorStop(0, "rgba(255,90,200,0.20)");
        aura.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = aura;
        ctx.beginPath();
        ctx.arc(cx, cy, size*1.35, 0, TAU);
        ctx.fill();
      }

      ctx.restore();
    }

    // ---------- Scene control ----------
    let running=false;
    let rays=[];
    let bokehs=[];
    let floatHearts=[];
    let t0=0;

    // ===== المطلوب: 5 ثواني =====
    const T_BUILD = 5000;

    // ===== للـ smooth dt =====
    let lastT = 0;

    // ===== نص: Trigger مرة واحدة لما يكتمل =====
    let textShown = false;

    // ===== تأخير ظهور النص 5 ثواني إضافية =====
    const TEXT_DELAY_MS = 5000;
    let textDelayTimer = null;

    function initBackground(){
      bokehs = Array.from({length: 12}, ()=>new Bokeh());
      floatHearts = Array.from({length: 14}, ()=>new FloatHeart());
    }

    function spawnRays(cx, cy, size, now, budget){
      for(let i=0;i<budget;i++){
        let idx = (Math.random()*HEART_POINTS.length)|0;

        if(Math.random() < 0.78){
          for(let k=0;k<5;k++){
            const j = (Math.random()*HEART_POINTS.length)|0;
            if(heartGlow[j] < heartGlow[idx]) idx = j;
          }
        }

        const target = mapToScreen(HEART_POINTS[idx], cx, cy, size);
        const swirlSign = (Math.random()<0.5)? -1 : 1;

        const r = new Ray(target, swirlSign);
        r._targetIndex = idx;
        r.col = rayColor((now - t0) * 0.02);
        rays.push(r);
      }

      const CAP = 2400;
      if(rays.length > CAP) rays.splice(0, rays.length - CAP);
    }

    // ===== Typewriter emotional text =====
    function typewriter(el, text, speedMs=34){
      el.textContent = "";
      let i=0;
      const tick = () => {
        i++;
        el.textContent = text.slice(0,i);
        if(i < text.length) setTimeout(tick, speedMs);
      };
      tick();
    }

    function animate(now){
      if(!running) return;

      // dt seconds (clamp عشان لو التاب اتجمد)
      const dt = clamp((now - lastT) / 1000, 0.001, 0.033);
      lastT = now;

      const cx = W/2, cy = H*0.50;
      const size = Math.min(W,H) * 0.30;

      drawCoverImage(bgImg);

      ctx.save();
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      for(const b of bokehs){ b.update(); b.draw(); }
      for(const h of floatHearts){ h.update(); h.draw(); }

      const elapsed = now - t0;
      const buildT = clamp(elapsed / T_BUILD, 0, 1);

      const budget = (buildT < 1)
        ? Math.floor(lerp(34, 18, buildT))   // خلال 5 ثواني
        : 10;                                 // بعد الاكتمال

      spawnRays(cx, cy, size, now, budget);

      updateHeartGlow(dt);

      const next=[];
      for(const r of rays){
        const alive = r.update(now, dt, cx, cy);
        r.draw();

        if(r.arrived && r._targetIndex != null){
          heartGlow[r._targetIndex] = clamp(heartGlow[r._targetIndex] + 0.55 * (dt*60), 0, 2.0);
          r._targetIndex = null;
        }

        if(alive) next.push(r);
      }
      rays = next;

      const baseAlpha = 0.20 + buildT*0.95;
      drawDottedHeart(cx, cy, size, baseAlpha);

      // ===== النص: بعد الاكتمال + تأخير 5 ثواني إضافية =====
      const formed = getFormedRatio();
      if(!textShown && (buildT >= 1 || formed > 0.78)){
        textShown = true;

        if(textDelayTimer) clearTimeout(textDelayTimer);
        textDelayTimer = setTimeout(()=>{
          caption.classList.add("show");
          subtitle.classList.add("show");

          const mainText = "Love You, Lil’ One — Ali";
          const subText  = "from the edges of the world… to the center of my heart";

          typewriter(caption, mainText, 28);
          setTimeout(()=>typewriter(subtitle, subText, 16), 900);
        }, TEXT_DELAY_MS);
      }

      requestAnimationFrame(animate);
    }

    function start(){
      btn.style.display="none";
      caption.classList.remove("show");
      subtitle.classList.remove("show");
      caption.textContent = "";
      subtitle.textContent = "";
      textShown = false;

      if(textDelayTimer) { clearTimeout(textDelayTimer); textDelayTimer = null; }

      initBackground();
      resetHeartGlow(HEART_POINTS.length);

      rays=[];
      running=true;
      t0=performance.now();
      lastT = t0;

      // ✅ تشغيل الصوت بعد الضغط على START مباشرة
      bgAudio.currentTime = 0;
      bgAudio.play().catch(()=>{ /* لو المتصفح منع autoplay */ });

      requestAnimationFrame(animate);
    }

    btn.addEventListener("click", start);
  </script>
</body>

</html>
